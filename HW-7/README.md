(25 б.) Перечислите алгоритмы стандартной библиотеки, которые Вы знаете, очень кратко пояснив, для чего применяется каждый из них.\
(10 б.) Для чего применяются итераторы? Какие операции с итераторами Вы можете назвать?\
(10 б.) Что такое концепция диапазонов и почему она используется в стандартной библиотеке?\
(10 б.) Как применять библиотеку random для генерации случайных чисел?\
(5 б.) Какой контейнер поддерживает быструю вставку элементов в начало?


----
1) Алгоритмы библиотеки <algorithm>:\
- min_element(начало, конец) - возвращает самый маленький элемент контейнера
- max_element(начало, конец) - // - // большой элемент контейнера
- minmax_element(начало, конец) - возвращает и большой и маленький
- pair<std::string, unsigned> (например) - хранит
- sort(начало, конец, компаратор) - сортирует массив по компаратору. По дефолту компаратор 
сортирует по возрастанию
- count(начало, конец, число) - считает количество заданных чисел
- count_if(начало, конец, компаратор) - считает количество чисел удовлетворяющих компоратор
- accumulate(начало, конец, компаратор) - производит вычисление среди всех членов по правилу компаратора (сложение, умножение и т.д.)
- inner_product(начало первого конт, его конец, начало второго) - скалярное произведение двух последовательностей
- remove(начало, конец, число) - перемещает заданное число в самый конец контейнера
- Удаление:\
  auto start = std::remove(начало, конец, число);\
  vect.erase(start, конец);
- for_each(начало, конец, компаратор) - делает операцию компоратора для каждого члена поочереди
---
2) Итераторы обеспечивают доступ к элементам контейнера. С помощью итераторов
   очень удобно перебирать элементы. Итератор описывается типом iterator.
   - *iter: получение элемента, на который указывает итератор
   - ++iter: перемещение итератора вперед для обращения к следующему элементу
   - --iter: перемещение итератора назад для обращения к предыдущему элементу. 
   - iter + n: возвращает итератор, который смещен от итератора iter на n позиций вперед
   - iter += n: перемещает итератор на n позиций вперед
   - iter1 - iter2: возвращает количество позиций между итераторами iter1 и iter2
----
3) Итератор сам по себе не знает, когда нужно остановиться. 
   Имея только итератор на начало последовательности, нельзя
   сказать, где конец этой последовательности. Поэтому мы объединяем пару 
   итераторов — начало и конец — в диапазон. Пример:
   >`std::vector<int> vect{1, .... , n};`\
   >`auto min = std::min_element(vect.begin(), vect.end());`\
   Где vect.begin(), vect.end() - это итераторы на начало и конец вектора
----
4) Генерация случайных чисел в библиотеке random. Рассмотрим сразу на примере:
   > `std::uniform_int_distribution<int> distr(1, 10);`\
   >> Здесь мы задаем стандартное распределение от 1 до 10
   > 
   > `std::default_random_engine engine_1( `\
   > `std::chrono::steady_clock::now().time_since_epoch().count()`\
   `);`
   >> Здесь мы возвращаем текущее время. Это нужно чтобы генератор принимал на вход
   >> каждый раз разные значения
   > 
   > `for(int i = 0; i < 10; i++){`\
   > `std::cout << distr(engine_1) << ' ' <<std::endl;`\
   > `}`
   >> Здесь мы осуществляем вывод десяти рандомных чисел, каждый раз передавая
   > генератору случайных чисел разный параметр
   > 
----
5) Контейнер 
   > std::deque
   
   Поддерживает вставку нового элемента в начало. Пример:
   > `std::deque<int> ints;`\
   `ints.push_front(1);`\
   `ints.push_front(54);`
   
   При считывании выведет `54, 1`
   
